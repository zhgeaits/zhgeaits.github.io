---
layout: post
title:  "Java的class字节码文件，classloader类加载机制学习笔记!"
date:   2013-03-17 13:00:03
categories: java
type: java&web
---

>我并不是java专家，对于更加深入的java虚拟机和相关的java语言规范并没有去深入学习，所以这里不是详细的学习教程，只不过是我学习java时候的一些笔记而已。

## 1.什么是java的类Class

刚学习C语言的时候，我才开始了解到编译器把C代码编译成obj二进制文件，然后进行链接，最后成为机器代码，这样计算机才能识别进行执行。而当我学习java的时候，确实把java代码编译成了class文件，那时候只知道这是被java虚拟机专属执行的字节码文件。因为java的目标是夸平台性的，所以它希望一次编译成功以后的class文件，不管在什么平台上面，只要装有java虚拟机都能够执行；而其实java虚拟机更是跨语言性的，不管是什么语言，只要被相应的编译器编译成class文件，都能够被执行，而目前这些语言包括了：java，groovy，jruby，scala等等。因此，class文件不过是被定义的一种文件格式罢了，因为它是字节码文件，它的每一个字节都被定义规范利用起来，然后虚拟机便能够识别来执行了。而这些定义都可以在The Java Language Specification和The Java Virtual Machine Specification上面查询。只要我们认真研究了这些规范以后，我们也就明白了其实可以进行反编译，那些反编译的工具也是这样来的，根据规范解析class文件罢了。

### 1.1 Class类文件结构

定义class类的结构用了两种数据类型：无符号数和表。无符号数只有u1,u2,u4,u8，分表描述一个结构用了1，2，4，8个字节。表则是由多个无符号数或者其他表作为数据项的符合类型（递归的定义方式）。本质上class文件就是一个表，它的项有无符号类型的，也有表类型的，就像代码里的类定义一样。

class文件结构大致包括了如下项：magic，version，constant\_pool，access_flags，this，super，interface，fields，methods，attributes。

我们可以使用jdk提供的工具来分析class文件：javap -verbose TestClass

下面分表描述各项：

魔法数就像文件扩展名一样告诉我们它的格式，确定这个文件是否为一个能被虚拟机接受的class文件，它的值固定为0xCAFEBABE，就是咖啡宝贝，哈哈，难怪java的图标是咖啡。

版本定义的就是编译的主版本和次版本，用来被虚拟机确定能否执行，或者兼容。

常量池这里存放了所有的常量，它是从1开始按顺序给每个常量编号，当别的项或者其他地方需要用到常量的时候，就指定一个索引指向即可。如果指向了常量池的0索引，则表示的是“不引用任何一个常量池项目”。常量池的项目类型包含多种，每一个类型都是表。某一项的表的值又可以指向了常量池的某一项。总之，常量池比较复杂，存放了类名，属性，方法名，方法的代码等等。

access_flags是16位的二进制表示类的访问限制。

this，super，interface的值分别指向不同的常量池的项，告诉我们本类名，父类名和实现的接口是什么。

每一个字段都需要一个表来存放，信息包括：访问标记，名字索引，描述符索引和属性。访问标记和类的差不多，名字索引是指向了常量池。描述符其实就是这个类型的简写，描述符索引也是指向了常量池，包括：B(byte)，C(char)，D(double)，F(float)，I(int)，J(long)，S(short)，Z(boolean)，V(void)，L(对象类型，如Ljava/lang/Object)，对于数组类型，则用一个[来表示，多一维就多一个[。属性则是指向了最后的属性集合。如果字段被final修饰，则这个就是常量，会出现在常量池和属性表（为什么出现两次？）。测试发现只用final修饰或者final+static修饰结构是一样的，但是只用static就不一样了。

存放方法的表结构和属性的表一样，但是方法的访问标记不一样，方法的描述符更复杂，先描述参数值，再描述返回值，例如：String a(int[] b)的描述符为([I)Ljava/lang/String。最后属性项存放的就是指向属性集合的索引。实际存放的就是方法体内的指令代码。

属性表存放了比较多的内容，包括了21项，方法指令，final修饰的常量，过时的方法和字段，异常表，行号，签名，源文件等等。属性表和常量池的除了有一个常量相同以外，其他都不同了。

## 2.类加载机制